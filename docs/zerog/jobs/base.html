<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>zerog.jobs.base API documentation</title>
<meta name="description" content="Copyright (c) 2017 MotiveMetrics. All rights reserved." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>zerog.jobs.base</code></h1>
</header>
<section id="section-intro">
<p>Copyright (c) 2017 MotiveMetrics. All rights reserved.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
&#34;&#34;&#34;
Copyright (c) 2017 MotiveMetrics. All rights reserved.

&#34;&#34;&#34;

#
# NOTES:
#   - make it possible to kill a job??
#

from abc import ABC, abstractmethod
import datetime
import random
import time
import uuid

from marshmallow import Schema, fields

from .error import ErrorSchema, make_error
from .event import EventSchema, make_event
from .warning import WarningSchema, make_warning

import logging
log = logging.getLogger(__name__)

DEFAULT_TTR = 3600 * 24   # long because broken workers are killed

# result codes
INTERNAL_ERROR = 500
NO_RESULT = -1

OVERRIDE_SIGNATURE = &#34;zerog_job&#34;


class ErrorContinue(Exception):
    pass


class ErrorFinish(Exception):
    pass


class WarningFinish(Exception):
    pass


class BaseJobSchema(Schema):
    &#34;&#34;&#34;
    Base Job Schema

    &#34;&#34;&#34;
    documentType = fields.String()
    jobType = fields.String()
    schemaVersion = fields.Float()

    createdAt = fields.DateTime(format=&#34;iso&#34;)
    updatedAt = fields.DateTime(format=&#34;iso&#34;)
    cas = fields.Integer()

    uuid = fields.String()
    logId = fields.String()

    queueName = fields.String()
    queueKwargs = fields.Dict()
    queueJobId = fields.Integer()

    events = fields.List(fields.Nested(EventSchema))
    errors = fields.List(fields.Nested(ErrorSchema))
    warnings = fields.List(fields.Nested(WarningSchema))

    completeness = fields.Float()
    tickcount = fields.Float()
    tickval = fields.Float()
    resultCode = fields.Integer()


class BaseJob(ABC):
    &#34;&#34;&#34;
    must override:
        JOB_TYPE
        SCHEMA

    may override:
        SCHEMA_VERSION

    do not override
        DOCUMENT_TYPE
    &#34;&#34;&#34;
    DOCUMENT_TYPE = &#34;zerog_job&#34;   # used to make datastore key
    SCHEMA_VERSION = &#34;1.0&#34;

    JOB_TYPE = OVERRIDE_SIGNATURE
    SCHEMA = OVERRIDE_SIGNATURE

    def __init__(self, datastore, queue, keepalive=None, **kwargs):
        self.datastore = datastore
        self.queue = queue
        self.keepalive = keepalive

        now = datetime.datetime.utcnow()

        self.documentType = kwargs.get(&#39;documentType&#39;, self.DOCUMENT_TYPE)
        self.jobType = kwargs.get(&#39;jobType&#39;, self.JOB_TYPE)
        self.schemaVersion = kwargs.get(&#39;schemaVersion&#39;, self.SCHEMA_VERSION)

        self.createdAt = kwargs.get(&#39;createdAt&#39;, now)
        self.updatedAt = kwargs.get(&#39;updatedAt&#39;, now)
        self.cas = kwargs.get(&#39;cas&#39;, 0)

        self.uuid = kwargs.get(&#39;uuid&#39;) or str(uuid.uuid4())
        self.logId = kwargs.get(
            &#39;logId&#39;,
            &#34;%s_%s&#34; % (self.JOB_TYPE, self.uuid)
        )

        self.queueKwargs = kwargs.get(&#39;queueKwargs&#39;, {})
        self.queueJobId = kwargs.get(&#39;queueJobId&#39;, 0)

        self.events = kwargs.get(&#39;events&#39;, [])
        self.errors = kwargs.get(&#39;errors&#39;, [])
        self.warnings = kwargs.get(&#39;warnings&#39;, [])

        self.completeness = kwargs.get(&#39;completeness&#39;, 0)
        self.tickcount = kwargs.get(&#39;tickcount&#39;, 0.0)
        self.tickval = kwargs.get(&#39;tickval&#39;, 0.001)
        self.resultCode = kwargs.get(&#39;resultCode&#39;, NO_RESULT)

    def dump(self):
        return self.SCHEMA().dump(self)

    def dumps(self, **kwargs):
        return self.SCHEMA().dumps(self, **kwargs)

    def __str__(self):
        return self.dumps(indent=4)

    def key(self):
        return make_key(self.uuid)

    def save(self):
        &#34;&#34;&#34;
        Saves job instance to the datastore. Current implementation uses
        Couchbase for the datastore.
        &#34;&#34;&#34;
        self.updatedAt = datetime.datetime.utcnow()
        _, self.cas = self.datastore.set_with_cas(
            self.key(),
            self.dump(),
            cas=self.cas
        )

    def reload(self):
        &#34;&#34;&#34;
        Reload job data by repulling from the datastore.

        This may be necessary if another python instance has updated this job
        in the datastore and the cas loaded here is out of date.
        &#34;&#34;&#34;
        data, cas = self.datastore.read_with_cas(self.key())
        if data:
            data[&#39;cas&#39;] = cas
            loaded = self.SCHEMA().load(data)
            self.__init__(self.datastore, self.queue, **loaded)

    def record_change(self, func, *args, **kwargs):
        &#34;&#34;&#34;
        Use func to update this job instance and save the updated instance to
        the datastore.

        In case of an error, reload the job from the datastore and retry.

        NOTE: How much is couchbase dependent?
        &#34;&#34;&#34;
        for _ in range(10):
            try:
                func(*args, **kwargs)
                self.save()
                return True

            except self.datastore.casException:
                log.info(&#34;%s: datastore collision - reloading.&#34; % self.logId)

            except self.datastore.lockedException:
                log.info(&#34;%s: locked - reloading.&#34; % self.logId)

            time.sleep(random.random() / 10)
            self.reload()

        log.error(&#34;%s: save failed - too many tries&#34; % self.logId)
        return False

    def update_attrs(self, **kwargs):
        &#34;&#34;&#34;
        Updates a job&#39;s attributes. Saves the update to the datastore.
        &#34;&#34;&#34;
        def do_update_attrs():
            for attr, value in kwargs.items():
                setattr(self, attr, value)

        self.record_change(do_update_attrs)

    def record_event(self, msg):
        &#34;&#34;&#34;
        Makes and records an event associated with this job.
        &#34;&#34;&#34;
        event = make_event(msg)

        def do_record_event():
            self.events.append(event)

        self.record_change(do_record_event)

    def record_warning(self, msg):
        &#34;&#34;&#34;
        Makes and records a warning associated with this job.
        &#34;&#34;&#34;
        warning = make_warning(msg)

        def do_record_warning():
            self.warnings.append(warning)

        self.record_change(do_record_warning)

    def record_error(self, errorCode, msg):
        &#34;&#34;&#34;
        Makes and records an error associated with this job.
        &#34;&#34;&#34;
        error = make_error(errorCode, msg)

        def do_record_error():
            self.errors.append(error)

        self.record_change(do_record_error)

    def record_result(self, resultCode):
        &#34;&#34;&#34;
        Record the result of a job.
        &#34;&#34;&#34;
        self.update_attrs(
            resultCode=resultCode,
            completeness=1
        )

    def keep_alive(self):
        if self.keepalive and callable(self.keepalive):
            self.keepalive()

    def job_log_info(self, msg):
        log.info(msg)
        self.record_event(msg)

    def job_log_warning(self, msg):
        log.warning(msg)
        self.record_warning(msg)

    def job_log_error(self, errorCode, msg):
        log.error(msg)
        self.record_error(errorCode, msg)

    def raise_warning_finish(self, resultCode, msg):
        self.job_log_warning(msg)
        self.record_result(resultCode)
        raise WarningFinish

    def raise_error_continue(self, errorCode, msg):
        self.job_log_error(errorCode, msg)
        raise ErrorContinue

    def raise_error_finish(self, errorCode, msg):
        self.job_log_error(errorCode, msg)
        self.record_result(errorCode)
        raise ErrorFinish

    def set_completeness(self, completeness):
        &#34;&#34;&#34;
        Sets the absolute value of the job&#39;s completeness. Clamps
        value to a range of 0.0 to 1.0
        &#34;&#34;&#34;
        self.keep_alive()
        setval = clamp(completeness, 0.0, 1.0)

        if completeness &lt; 0 or completeness &gt; 1:
            log.warning(
                &#34;completeness %d out of range. Clamping to %d&#34; %
                (completeness, setval)
            )

        self.update_attrs(completeness=setval, tickcount=self.tickcount)

    def add_to_completeness(self, delta):
        &#34;&#34;&#34;
        Increment the job&#39;s completeness. Adds any unrecorded ticks.
        Resulting completeness will be clamped to a range of 0.0 to 1.0.
        &#34;&#34;&#34;
        self.set_completeness(self.completeness + delta + self.tickcount)

    def set_tick_value(self, tickval):
        &#34;&#34;&#34;
        Sets the amount the job&#39;s completeness will be incremented
        by a call to the tick method
        &#34;&#34;&#34;
        self.update_attrs(tickval=tickval)

    def tick(self):
        &#34;&#34;&#34;
        Accumulates the job&#39;s tickcount. Adds tickcount to completeness
        when it is &gt;= 0.01
        &#34;&#34;&#34;
        self.tickcount += self.tickval

        if self.tickcount &gt;= 0.01:
            self.add_to_completeness(0)
            self.tickcount = 0

    def enqueue(self, **kwargs):
        &#34;&#34;&#34;
        Add a job to its queue. The queue is defined by the subclass of
        BaseJob.
        &#34;&#34;&#34;

        # if the job has not been added to the database yet, cas is 0
        if self.cas == 0:
            self.save()

        # thought: does this ever enqueue the job but then fail on the update?
        # what happens then?
        kwargs[&#39;ttr&#39;] = kwargs.get(&#39;ttr&#39;, DEFAULT_TTR)
        queueJobId = self.queue.put(self.uuid, **kwargs)

        self.update_attrs(queueKwargs=kwargs, queueJobId=queueJobId)

    def progress(self):
        &#34;&#34;&#34;
        Returns a job&#39;s completeness, result, events, and errors.

        Override this method to add additional return values. Use super
        to call this method and get the base return values.
        &#34;&#34;&#34;
        return dict(
            completeness=self.completeness,
            result=self.resultCode,
            events=[e.dump() for e in self.events],
            errors=[e.dump() for e in self.errors],
            warnings=[w.dump() for w in self.warnings]
        )

    @abstractmethod
    def run(self):
        # override this method to execute the job. It is called by
        # the base worker once the job has been successfully loaded
        #
        # Must return:
        #
        #   resultCode: resultCode for the job. Return NO_RESULT if job needs
        #               to be requeued for further processing. Otherwise use
        #               HTTP resultCodes (200s for success, etc.)
        #
        pass


def make_key(uuid):
    &#34;&#34;&#34;
    Makes a unique datastore key for a job.

    Args:
        uuid: uuid of the job

    Returns:
        datastore key
    &#34;&#34;&#34;
    return &#34;%s_%s&#34; % (BaseJob.DOCUMENT_TYPE, uuid)


def clamp(value, minval, maxval):
    return (max(min(maxval, value), minval))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="zerog.jobs.base.clamp"><code class="name flex">
<span>def <span class="ident">clamp</span></span>(<span>value, minval, maxval)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp(value, minval, maxval):
    return (max(min(maxval, value), minval))</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.make_key"><code class="name flex">
<span>def <span class="ident">make_key</span></span>(<span>uuid)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a unique datastore key for a job.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uuid</code></strong></dt>
<dd>uuid of the job</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datastore key</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_key(uuid):
    &#34;&#34;&#34;
    Makes a unique datastore key for a job.

    Args:
        uuid: uuid of the job

    Returns:
        datastore key
    &#34;&#34;&#34;
    return &#34;%s_%s&#34; % (BaseJob.DOCUMENT_TYPE, uuid)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="zerog.jobs.base.BaseJob"><code class="flex name class">
<span>class <span class="ident">BaseJob</span></span>
<span>(</span><span>datastore, queue, keepalive=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>must override:
JOB_TYPE
SCHEMA</p>
<p>may override:
SCHEMA_VERSION</p>
<p>do not override
DOCUMENT_TYPE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseJob(ABC):
    &#34;&#34;&#34;
    must override:
        JOB_TYPE
        SCHEMA

    may override:
        SCHEMA_VERSION

    do not override
        DOCUMENT_TYPE
    &#34;&#34;&#34;
    DOCUMENT_TYPE = &#34;zerog_job&#34;   # used to make datastore key
    SCHEMA_VERSION = &#34;1.0&#34;

    JOB_TYPE = OVERRIDE_SIGNATURE
    SCHEMA = OVERRIDE_SIGNATURE

    def __init__(self, datastore, queue, keepalive=None, **kwargs):
        self.datastore = datastore
        self.queue = queue
        self.keepalive = keepalive

        now = datetime.datetime.utcnow()

        self.documentType = kwargs.get(&#39;documentType&#39;, self.DOCUMENT_TYPE)
        self.jobType = kwargs.get(&#39;jobType&#39;, self.JOB_TYPE)
        self.schemaVersion = kwargs.get(&#39;schemaVersion&#39;, self.SCHEMA_VERSION)

        self.createdAt = kwargs.get(&#39;createdAt&#39;, now)
        self.updatedAt = kwargs.get(&#39;updatedAt&#39;, now)
        self.cas = kwargs.get(&#39;cas&#39;, 0)

        self.uuid = kwargs.get(&#39;uuid&#39;) or str(uuid.uuid4())
        self.logId = kwargs.get(
            &#39;logId&#39;,
            &#34;%s_%s&#34; % (self.JOB_TYPE, self.uuid)
        )

        self.queueKwargs = kwargs.get(&#39;queueKwargs&#39;, {})
        self.queueJobId = kwargs.get(&#39;queueJobId&#39;, 0)

        self.events = kwargs.get(&#39;events&#39;, [])
        self.errors = kwargs.get(&#39;errors&#39;, [])
        self.warnings = kwargs.get(&#39;warnings&#39;, [])

        self.completeness = kwargs.get(&#39;completeness&#39;, 0)
        self.tickcount = kwargs.get(&#39;tickcount&#39;, 0.0)
        self.tickval = kwargs.get(&#39;tickval&#39;, 0.001)
        self.resultCode = kwargs.get(&#39;resultCode&#39;, NO_RESULT)

    def dump(self):
        return self.SCHEMA().dump(self)

    def dumps(self, **kwargs):
        return self.SCHEMA().dumps(self, **kwargs)

    def __str__(self):
        return self.dumps(indent=4)

    def key(self):
        return make_key(self.uuid)

    def save(self):
        &#34;&#34;&#34;
        Saves job instance to the datastore. Current implementation uses
        Couchbase for the datastore.
        &#34;&#34;&#34;
        self.updatedAt = datetime.datetime.utcnow()
        _, self.cas = self.datastore.set_with_cas(
            self.key(),
            self.dump(),
            cas=self.cas
        )

    def reload(self):
        &#34;&#34;&#34;
        Reload job data by repulling from the datastore.

        This may be necessary if another python instance has updated this job
        in the datastore and the cas loaded here is out of date.
        &#34;&#34;&#34;
        data, cas = self.datastore.read_with_cas(self.key())
        if data:
            data[&#39;cas&#39;] = cas
            loaded = self.SCHEMA().load(data)
            self.__init__(self.datastore, self.queue, **loaded)

    def record_change(self, func, *args, **kwargs):
        &#34;&#34;&#34;
        Use func to update this job instance and save the updated instance to
        the datastore.

        In case of an error, reload the job from the datastore and retry.

        NOTE: How much is couchbase dependent?
        &#34;&#34;&#34;
        for _ in range(10):
            try:
                func(*args, **kwargs)
                self.save()
                return True

            except self.datastore.casException:
                log.info(&#34;%s: datastore collision - reloading.&#34; % self.logId)

            except self.datastore.lockedException:
                log.info(&#34;%s: locked - reloading.&#34; % self.logId)

            time.sleep(random.random() / 10)
            self.reload()

        log.error(&#34;%s: save failed - too many tries&#34; % self.logId)
        return False

    def update_attrs(self, **kwargs):
        &#34;&#34;&#34;
        Updates a job&#39;s attributes. Saves the update to the datastore.
        &#34;&#34;&#34;
        def do_update_attrs():
            for attr, value in kwargs.items():
                setattr(self, attr, value)

        self.record_change(do_update_attrs)

    def record_event(self, msg):
        &#34;&#34;&#34;
        Makes and records an event associated with this job.
        &#34;&#34;&#34;
        event = make_event(msg)

        def do_record_event():
            self.events.append(event)

        self.record_change(do_record_event)

    def record_warning(self, msg):
        &#34;&#34;&#34;
        Makes and records a warning associated with this job.
        &#34;&#34;&#34;
        warning = make_warning(msg)

        def do_record_warning():
            self.warnings.append(warning)

        self.record_change(do_record_warning)

    def record_error(self, errorCode, msg):
        &#34;&#34;&#34;
        Makes and records an error associated with this job.
        &#34;&#34;&#34;
        error = make_error(errorCode, msg)

        def do_record_error():
            self.errors.append(error)

        self.record_change(do_record_error)

    def record_result(self, resultCode):
        &#34;&#34;&#34;
        Record the result of a job.
        &#34;&#34;&#34;
        self.update_attrs(
            resultCode=resultCode,
            completeness=1
        )

    def keep_alive(self):
        if self.keepalive and callable(self.keepalive):
            self.keepalive()

    def job_log_info(self, msg):
        log.info(msg)
        self.record_event(msg)

    def job_log_warning(self, msg):
        log.warning(msg)
        self.record_warning(msg)

    def job_log_error(self, errorCode, msg):
        log.error(msg)
        self.record_error(errorCode, msg)

    def raise_warning_finish(self, resultCode, msg):
        self.job_log_warning(msg)
        self.record_result(resultCode)
        raise WarningFinish

    def raise_error_continue(self, errorCode, msg):
        self.job_log_error(errorCode, msg)
        raise ErrorContinue

    def raise_error_finish(self, errorCode, msg):
        self.job_log_error(errorCode, msg)
        self.record_result(errorCode)
        raise ErrorFinish

    def set_completeness(self, completeness):
        &#34;&#34;&#34;
        Sets the absolute value of the job&#39;s completeness. Clamps
        value to a range of 0.0 to 1.0
        &#34;&#34;&#34;
        self.keep_alive()
        setval = clamp(completeness, 0.0, 1.0)

        if completeness &lt; 0 or completeness &gt; 1:
            log.warning(
                &#34;completeness %d out of range. Clamping to %d&#34; %
                (completeness, setval)
            )

        self.update_attrs(completeness=setval, tickcount=self.tickcount)

    def add_to_completeness(self, delta):
        &#34;&#34;&#34;
        Increment the job&#39;s completeness. Adds any unrecorded ticks.
        Resulting completeness will be clamped to a range of 0.0 to 1.0.
        &#34;&#34;&#34;
        self.set_completeness(self.completeness + delta + self.tickcount)

    def set_tick_value(self, tickval):
        &#34;&#34;&#34;
        Sets the amount the job&#39;s completeness will be incremented
        by a call to the tick method
        &#34;&#34;&#34;
        self.update_attrs(tickval=tickval)

    def tick(self):
        &#34;&#34;&#34;
        Accumulates the job&#39;s tickcount. Adds tickcount to completeness
        when it is &gt;= 0.01
        &#34;&#34;&#34;
        self.tickcount += self.tickval

        if self.tickcount &gt;= 0.01:
            self.add_to_completeness(0)
            self.tickcount = 0

    def enqueue(self, **kwargs):
        &#34;&#34;&#34;
        Add a job to its queue. The queue is defined by the subclass of
        BaseJob.
        &#34;&#34;&#34;

        # if the job has not been added to the database yet, cas is 0
        if self.cas == 0:
            self.save()

        # thought: does this ever enqueue the job but then fail on the update?
        # what happens then?
        kwargs[&#39;ttr&#39;] = kwargs.get(&#39;ttr&#39;, DEFAULT_TTR)
        queueJobId = self.queue.put(self.uuid, **kwargs)

        self.update_attrs(queueKwargs=kwargs, queueJobId=queueJobId)

    def progress(self):
        &#34;&#34;&#34;
        Returns a job&#39;s completeness, result, events, and errors.

        Override this method to add additional return values. Use super
        to call this method and get the base return values.
        &#34;&#34;&#34;
        return dict(
            completeness=self.completeness,
            result=self.resultCode,
            events=[e.dump() for e in self.events],
            errors=[e.dump() for e in self.errors],
            warnings=[w.dump() for w in self.warnings]
        )

    @abstractmethod
    def run(self):
        # override this method to execute the job. It is called by
        # the base worker once the job has been successfully loaded
        #
        # Must return:
        #
        #   resultCode: resultCode for the job. Return NO_RESULT if job needs
        #               to be requeued for further processing. Otherwise use
        #               HTTP resultCodes (200s for success, etc.)
        #
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="zerog.jobs.base.BaseJob.DOCUMENT_TYPE"><code class="name">var <span class="ident">DOCUMENT_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="zerog.jobs.base.BaseJob.JOB_TYPE"><code class="name">var <span class="ident">JOB_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="zerog.jobs.base.BaseJob.SCHEMA"><code class="name">var <span class="ident">SCHEMA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="zerog.jobs.base.BaseJob.SCHEMA_VERSION"><code class="name">var <span class="ident">SCHEMA_VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="zerog.jobs.base.BaseJob.add_to_completeness"><code class="name flex">
<span>def <span class="ident">add_to_completeness</span></span>(<span>self, delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment the job's completeness. Adds any unrecorded ticks.
Resulting completeness will be clamped to a range of 0.0 to 1.0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_completeness(self, delta):
    &#34;&#34;&#34;
    Increment the job&#39;s completeness. Adds any unrecorded ticks.
    Resulting completeness will be clamped to a range of 0.0 to 1.0.
    &#34;&#34;&#34;
    self.set_completeness(self.completeness + delta + self.tickcount)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self):
    return self.SCHEMA().dump(self)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(self, **kwargs):
    return self.SCHEMA().dumps(self, **kwargs)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.enqueue"><code class="name flex">
<span>def <span class="ident">enqueue</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a job to its queue. The queue is defined by the subclass of
BaseJob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enqueue(self, **kwargs):
    &#34;&#34;&#34;
    Add a job to its queue. The queue is defined by the subclass of
    BaseJob.
    &#34;&#34;&#34;

    # if the job has not been added to the database yet, cas is 0
    if self.cas == 0:
        self.save()

    # thought: does this ever enqueue the job but then fail on the update?
    # what happens then?
    kwargs[&#39;ttr&#39;] = kwargs.get(&#39;ttr&#39;, DEFAULT_TTR)
    queueJobId = self.queue.put(self.uuid, **kwargs)

    self.update_attrs(queueKwargs=kwargs, queueJobId=queueJobId)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.job_log_error"><code class="name flex">
<span>def <span class="ident">job_log_error</span></span>(<span>self, errorCode, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def job_log_error(self, errorCode, msg):
    log.error(msg)
    self.record_error(errorCode, msg)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.job_log_info"><code class="name flex">
<span>def <span class="ident">job_log_info</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def job_log_info(self, msg):
    log.info(msg)
    self.record_event(msg)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.job_log_warning"><code class="name flex">
<span>def <span class="ident">job_log_warning</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def job_log_warning(self, msg):
    log.warning(msg)
    self.record_warning(msg)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.keep_alive"><code class="name flex">
<span>def <span class="ident">keep_alive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keep_alive(self):
    if self.keepalive and callable(self.keepalive):
        self.keepalive()</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.key"><code class="name flex">
<span>def <span class="ident">key</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key(self):
    return make_key(self.uuid)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a job's completeness, result, events, and errors.</p>
<p>Override this method to add additional return values. Use super
to call this method and get the base return values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress(self):
    &#34;&#34;&#34;
    Returns a job&#39;s completeness, result, events, and errors.

    Override this method to add additional return values. Use super
    to call this method and get the base return values.
    &#34;&#34;&#34;
    return dict(
        completeness=self.completeness,
        result=self.resultCode,
        events=[e.dump() for e in self.events],
        errors=[e.dump() for e in self.errors],
        warnings=[w.dump() for w in self.warnings]
    )</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.raise_error_continue"><code class="name flex">
<span>def <span class="ident">raise_error_continue</span></span>(<span>self, errorCode, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_error_continue(self, errorCode, msg):
    self.job_log_error(errorCode, msg)
    raise ErrorContinue</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.raise_error_finish"><code class="name flex">
<span>def <span class="ident">raise_error_finish</span></span>(<span>self, errorCode, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_error_finish(self, errorCode, msg):
    self.job_log_error(errorCode, msg)
    self.record_result(errorCode)
    raise ErrorFinish</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.raise_warning_finish"><code class="name flex">
<span>def <span class="ident">raise_warning_finish</span></span>(<span>self, resultCode, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_warning_finish(self, resultCode, msg):
    self.job_log_warning(msg)
    self.record_result(resultCode)
    raise WarningFinish</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.record_change"><code class="name flex">
<span>def <span class="ident">record_change</span></span>(<span>self, func, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Use func to update this job instance and save the updated instance to
the datastore.</p>
<p>In case of an error, reload the job from the datastore and retry.</p>
<p>NOTE: How much is couchbase dependent?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_change(self, func, *args, **kwargs):
    &#34;&#34;&#34;
    Use func to update this job instance and save the updated instance to
    the datastore.

    In case of an error, reload the job from the datastore and retry.

    NOTE: How much is couchbase dependent?
    &#34;&#34;&#34;
    for _ in range(10):
        try:
            func(*args, **kwargs)
            self.save()
            return True

        except self.datastore.casException:
            log.info(&#34;%s: datastore collision - reloading.&#34; % self.logId)

        except self.datastore.lockedException:
            log.info(&#34;%s: locked - reloading.&#34; % self.logId)

        time.sleep(random.random() / 10)
        self.reload()

    log.error(&#34;%s: save failed - too many tries&#34; % self.logId)
    return False</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.record_error"><code class="name flex">
<span>def <span class="ident">record_error</span></span>(<span>self, errorCode, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes and records an error associated with this job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_error(self, errorCode, msg):
    &#34;&#34;&#34;
    Makes and records an error associated with this job.
    &#34;&#34;&#34;
    error = make_error(errorCode, msg)

    def do_record_error():
        self.errors.append(error)

    self.record_change(do_record_error)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.record_event"><code class="name flex">
<span>def <span class="ident">record_event</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes and records an event associated with this job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_event(self, msg):
    &#34;&#34;&#34;
    Makes and records an event associated with this job.
    &#34;&#34;&#34;
    event = make_event(msg)

    def do_record_event():
        self.events.append(event)

    self.record_change(do_record_event)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.record_result"><code class="name flex">
<span>def <span class="ident">record_result</span></span>(<span>self, resultCode)</span>
</code></dt>
<dd>
<div class="desc"><p>Record the result of a job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_result(self, resultCode):
    &#34;&#34;&#34;
    Record the result of a job.
    &#34;&#34;&#34;
    self.update_attrs(
        resultCode=resultCode,
        completeness=1
    )</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.record_warning"><code class="name flex">
<span>def <span class="ident">record_warning</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes and records a warning associated with this job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_warning(self, msg):
    &#34;&#34;&#34;
    Makes and records a warning associated with this job.
    &#34;&#34;&#34;
    warning = make_warning(msg)

    def do_record_warning():
        self.warnings.append(warning)

    self.record_change(do_record_warning)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reload job data by repulling from the datastore.</p>
<p>This may be necessary if another python instance has updated this job
in the datastore and the cas loaded here is out of date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self):
    &#34;&#34;&#34;
    Reload job data by repulling from the datastore.

    This may be necessary if another python instance has updated this job
    in the datastore and the cas loaded here is out of date.
    &#34;&#34;&#34;
    data, cas = self.datastore.read_with_cas(self.key())
    if data:
        data[&#39;cas&#39;] = cas
        loaded = self.SCHEMA().load(data)
        self.__init__(self.datastore, self.queue, **loaded)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def run(self):
    # override this method to execute the job. It is called by
    # the base worker once the job has been successfully loaded
    #
    # Must return:
    #
    #   resultCode: resultCode for the job. Return NO_RESULT if job needs
    #               to be requeued for further processing. Otherwise use
    #               HTTP resultCodes (200s for success, etc.)
    #
    pass</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves job instance to the datastore. Current implementation uses
Couchbase for the datastore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#34;&#34;&#34;
    Saves job instance to the datastore. Current implementation uses
    Couchbase for the datastore.
    &#34;&#34;&#34;
    self.updatedAt = datetime.datetime.utcnow()
    _, self.cas = self.datastore.set_with_cas(
        self.key(),
        self.dump(),
        cas=self.cas
    )</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.set_completeness"><code class="name flex">
<span>def <span class="ident">set_completeness</span></span>(<span>self, completeness)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the absolute value of the job's completeness. Clamps
value to a range of 0.0 to 1.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_completeness(self, completeness):
    &#34;&#34;&#34;
    Sets the absolute value of the job&#39;s completeness. Clamps
    value to a range of 0.0 to 1.0
    &#34;&#34;&#34;
    self.keep_alive()
    setval = clamp(completeness, 0.0, 1.0)

    if completeness &lt; 0 or completeness &gt; 1:
        log.warning(
            &#34;completeness %d out of range. Clamping to %d&#34; %
            (completeness, setval)
        )

    self.update_attrs(completeness=setval, tickcount=self.tickcount)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.set_tick_value"><code class="name flex">
<span>def <span class="ident">set_tick_value</span></span>(<span>self, tickval)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the amount the job's completeness will be incremented
by a call to the tick method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tick_value(self, tickval):
    &#34;&#34;&#34;
    Sets the amount the job&#39;s completeness will be incremented
    by a call to the tick method
    &#34;&#34;&#34;
    self.update_attrs(tickval=tickval)</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulates the job's tickcount. Adds tickcount to completeness
when it is &gt;= 0.01</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self):
    &#34;&#34;&#34;
    Accumulates the job&#39;s tickcount. Adds tickcount to completeness
    when it is &gt;= 0.01
    &#34;&#34;&#34;
    self.tickcount += self.tickval

    if self.tickcount &gt;= 0.01:
        self.add_to_completeness(0)
        self.tickcount = 0</code></pre>
</details>
</dd>
<dt id="zerog.jobs.base.BaseJob.update_attrs"><code class="name flex">
<span>def <span class="ident">update_attrs</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a job's attributes. Saves the update to the datastore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attrs(self, **kwargs):
    &#34;&#34;&#34;
    Updates a job&#39;s attributes. Saves the update to the datastore.
    &#34;&#34;&#34;
    def do_update_attrs():
        for attr, value in kwargs.items():
            setattr(self, attr, value)

    self.record_change(do_update_attrs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="zerog.jobs.base.BaseJobSchema"><code class="flex name class">
<span>class <span class="ident">BaseJobSchema</span></span>
<span>(</span><span>*, only: Union[Sequence[str], Set[str]] = None, exclude: Union[Sequence[str], Set[str]] = (), many: bool = False, context: Dict = None, load_only: Union[Sequence[str], Set[str]] = (), dump_only: Union[Sequence[str], Set[str]] = (), partial: Union[bool, Sequence[str], Set[str]] = False, unknown: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base Job Schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseJobSchema(Schema):
    &#34;&#34;&#34;
    Base Job Schema

    &#34;&#34;&#34;
    documentType = fields.String()
    jobType = fields.String()
    schemaVersion = fields.Float()

    createdAt = fields.DateTime(format=&#34;iso&#34;)
    updatedAt = fields.DateTime(format=&#34;iso&#34;)
    cas = fields.Integer()

    uuid = fields.String()
    logId = fields.String()

    queueName = fields.String()
    queueKwargs = fields.Dict()
    queueJobId = fields.Integer()

    events = fields.List(fields.Nested(EventSchema))
    errors = fields.List(fields.Nested(ErrorSchema))
    warnings = fields.List(fields.Nested(WarningSchema))

    completeness = fields.Float()
    tickcount = fields.Float()
    tickval = fields.Float()
    resultCode = fields.Integer()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>marshmallow.schema.Schema</li>
<li>marshmallow.base.SchemaABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="zerog.jobs.base.BaseJobSchema.opts"><code class="name">var <span class="ident">opts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="zerog.jobs.base.ErrorContinue"><code class="flex name class">
<span>class <span class="ident">ErrorContinue</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorContinue(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="zerog.jobs.base.ErrorFinish"><code class="flex name class">
<span>class <span class="ident">ErrorFinish</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorFinish(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="zerog.jobs.base.WarningFinish"><code class="flex name class">
<span>class <span class="ident">WarningFinish</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WarningFinish(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="zerog.jobs" href="index.html">zerog.jobs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="zerog.jobs.base.clamp" href="#zerog.jobs.base.clamp">clamp</a></code></li>
<li><code><a title="zerog.jobs.base.make_key" href="#zerog.jobs.base.make_key">make_key</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="zerog.jobs.base.BaseJob" href="#zerog.jobs.base.BaseJob">BaseJob</a></code></h4>
<ul class="">
<li><code><a title="zerog.jobs.base.BaseJob.DOCUMENT_TYPE" href="#zerog.jobs.base.BaseJob.DOCUMENT_TYPE">DOCUMENT_TYPE</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.JOB_TYPE" href="#zerog.jobs.base.BaseJob.JOB_TYPE">JOB_TYPE</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.SCHEMA" href="#zerog.jobs.base.BaseJob.SCHEMA">SCHEMA</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.SCHEMA_VERSION" href="#zerog.jobs.base.BaseJob.SCHEMA_VERSION">SCHEMA_VERSION</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.add_to_completeness" href="#zerog.jobs.base.BaseJob.add_to_completeness">add_to_completeness</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.dump" href="#zerog.jobs.base.BaseJob.dump">dump</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.dumps" href="#zerog.jobs.base.BaseJob.dumps">dumps</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.enqueue" href="#zerog.jobs.base.BaseJob.enqueue">enqueue</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.job_log_error" href="#zerog.jobs.base.BaseJob.job_log_error">job_log_error</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.job_log_info" href="#zerog.jobs.base.BaseJob.job_log_info">job_log_info</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.job_log_warning" href="#zerog.jobs.base.BaseJob.job_log_warning">job_log_warning</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.keep_alive" href="#zerog.jobs.base.BaseJob.keep_alive">keep_alive</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.key" href="#zerog.jobs.base.BaseJob.key">key</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.progress" href="#zerog.jobs.base.BaseJob.progress">progress</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.raise_error_continue" href="#zerog.jobs.base.BaseJob.raise_error_continue">raise_error_continue</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.raise_error_finish" href="#zerog.jobs.base.BaseJob.raise_error_finish">raise_error_finish</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.raise_warning_finish" href="#zerog.jobs.base.BaseJob.raise_warning_finish">raise_warning_finish</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.record_change" href="#zerog.jobs.base.BaseJob.record_change">record_change</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.record_error" href="#zerog.jobs.base.BaseJob.record_error">record_error</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.record_event" href="#zerog.jobs.base.BaseJob.record_event">record_event</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.record_result" href="#zerog.jobs.base.BaseJob.record_result">record_result</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.record_warning" href="#zerog.jobs.base.BaseJob.record_warning">record_warning</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.reload" href="#zerog.jobs.base.BaseJob.reload">reload</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.run" href="#zerog.jobs.base.BaseJob.run">run</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.save" href="#zerog.jobs.base.BaseJob.save">save</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.set_completeness" href="#zerog.jobs.base.BaseJob.set_completeness">set_completeness</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.set_tick_value" href="#zerog.jobs.base.BaseJob.set_tick_value">set_tick_value</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.tick" href="#zerog.jobs.base.BaseJob.tick">tick</a></code></li>
<li><code><a title="zerog.jobs.base.BaseJob.update_attrs" href="#zerog.jobs.base.BaseJob.update_attrs">update_attrs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="zerog.jobs.base.BaseJobSchema" href="#zerog.jobs.base.BaseJobSchema">BaseJobSchema</a></code></h4>
<ul class="">
<li><code><a title="zerog.jobs.base.BaseJobSchema.opts" href="#zerog.jobs.base.BaseJobSchema.opts">opts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="zerog.jobs.base.ErrorContinue" href="#zerog.jobs.base.ErrorContinue">ErrorContinue</a></code></h4>
</li>
<li>
<h4><code><a title="zerog.jobs.base.ErrorFinish" href="#zerog.jobs.base.ErrorFinish">ErrorFinish</a></code></h4>
</li>
<li>
<h4><code><a title="zerog.jobs.base.WarningFinish" href="#zerog.jobs.base.WarningFinish">WarningFinish</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>